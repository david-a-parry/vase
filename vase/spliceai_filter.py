import sys
import gzip
from collections import defaultdict

pre_scored_fields = ["SYMBOL", "DS_AG", "DS_AL", "DS_DG", "DS_DL", "DP_AG",
                     "DP_AL", "DP_DG", "DP_DL"]
annot_order = ["ALLELE", "SYMBOL", "DS_AG", "DS_AL", "DS_DG", "DS_DL", "DP_AG",
               "DP_AL", "DP_DG", "DP_DL"]


class SpliceAiFilter(object):
    '''
        An object that annotates or filters VCF records based on SpliceAI
        annotations from SpliceAI score VCF.
    '''

    def __init__(self, vcfs, min_score=None, max_score=None, to_score=None):
        '''
            Initialize object with a VCF file and optional filtering
            arguments.

            Args:
                vcfs:       One or more VCFs containing variants to use
                            to filter or annotate records. SpliceAI INFO
                            fields must be present in the format produced
                            for pre-scored variants as downloaded from
                            Jaganathan et al. Cell (2018) or else as
                            generated by the SpliceAI program.

                min_delta:  Return True for each allele if any delta
                            score reaches this value.

                max_delta:  Return True for each allele if any delta
                            score reaches is below this value.

                to_score:   Name of file for writing variants which
                            cannot be found in the given SpliceAI VCFs.
                            If a variant passed to the annotate_or_filter
                            method is not found it will be written to
                            this file in VCF format for scoring with
                            SpliceAI. The scored file can then be used as
                            an additional reference file for scoring
                            variants.

        '''
        self.vcfs = dict()
        self.min_delta = min_delta
        self.max_delta = max_delta
        self.to_score = to_score
        self.to_score_file = None
        for vcf in vcfs:
            self.vcfs[vcf] = VcfReader(vcf)
        self.info_fields = {'SpliceAI': {'Number': '.',
                                         'Type': 'String',
                                         'Description': '"SpliceAI variant ' +
                                         'annotation. These include delta ' +
                                         'scores (DS) and delta positions ' +
                                         '(DP) for acceptor gain (AG), ' +
                                         'acceptor loss (AL), donor gain ' +
                                         '(DG), and donor loss (DL). Format:' +
                                         'ALLELE|SYMBOL|DS_AG|DS_AL|DS_DG|' +
                                         'DS_DL|DP_AG|DP_AL|DP_DG|DP_DL"'}}
        self.vcf_is_prescored = dict()
        self._check_vcf_info()
        if to_score is not None:
            if not to_score.endswith('.gz'):
                to_score += '.gz'
            self.to_score_file = gzip.open(to_score, 'wt')

    def __del__(self):
        if self.to_score_file is not None:
            self.to_score_file.close()

    def _check_vcf_info(self):
       for vcf, vreader in self.vcfs.items():
            if 'SpliceAI' in vreader.metadata['INFO']:
                if vreader.metadata['INFO']['SpliceAI'][-1]['Number'] == '.':
                   #VCF is in SpliceAI annotated format
                   self.vcf_is_prescored[vcf] = False
                   break
            #not annotated by SpliceAI, check if has prescored fields
            for f in pre_scored_fields:
                if f not in vreader.metadata['INFO']:
                    raise RuntimeError("ERROR: neither SpliceAI or " +
                                       "individual delta score annotations " +
                                       "found in SpliceAI VCF. Please " +
                                       "ensure you are either using a VCF " +
                                       "annotated using the SpliceAI " +
                                       "program or in the pre-scored format " +
                                       "from the SpliceAI paper")
            self.vcf_is_prescored[vcf] = True

    def get_overlapping_records(self, record):
        '''
            For a given record, returns a list of overlapping records
            in the class's VCFs.
        '''
        start = record.POS
        end = record.SPAN
        overlapping = dict()
        for vcf, vreader in self.vcfs.items():
            vreader.set_region(record.CHROM, start - 1, end)
            overlapping[vcf] = list(s for s in vreader.parser)
        return overlapping

    def _get_annotation(self, record, alt_index, prescored=False):
        alt = record.ALLELES[alt_index + 1]
        if prescored:
            info_strings = ["|".join(record.INFO_FIELDS[x] for x in
                                   pre_scored_fields)]
            info_dict = dict([(x, [record.parsed_info_fields([x])[x]]) for x in
                             pre_scored_fields])
        else:
            splice_ai = rec.parsed_info_fields(['SpliceAI'])['SpliceAI']
            info_dict = defaultdict(list)
            info_string = []
            for s in splice_ai:
                scores = s.split('|')
                if scores[0] == alt:
                    info_strings.append('|'.join(scores[1:]))
                    for i in range(1, len(annot_order)):
                        if annot_order[i] == 'SYMBOL':
                            info_dict[annot_order[i]].append(scores[i])
                        else:
                            info_dict[annot_order[i]].append(float(scores[i]))
        return info_strings, info_dict

    def _search_annotations(self, alt_allele, overlaps):
        for vcf, olap in overlaps.items():
            for i in range(len(olap.DECOMPOSED_ALLELES)):
                if alt_allele == olap.DECOMPOSED_ALLELES[i]:
                    return self._get_annotation(olap, i,
                                                self.vcf_is_prescored[vcf])
        return None, None

    def annotate_or_filter(self, record, check_symbol=False):
        '''
            Add SpliceAI annotation for each ALT allele in record. If
            min_delta or max_delta are set return True/False for each
            ALT allele indicating whether they meet the criteria
            specified. Optionally also returns True/False for each CSQ
            annotation from by checking the gene symbol matches in the
            SpliceAI annotation.
        '''
        keep_alleles = [False] * (len(record.ALLELES) - 1)
        keep_csq = []
        if check_symbol:
            try:
                keep_csq = [False] * len(record.CSQ)
            except HeaderError:
                raise RuntimeError("Could not identify CSQ or ANN fields in " +
                                   "VCF header. Please ensure your input is " +
                                   "annotated with Ensembl's VEP")
        overlaps = self.get_overlapping_records(record)
        annotation = []
        for i in range(len(record.DECOMPOSED_ALLELES)):
            info_strings, info_dict = self._search_annotations(
                record.DECOMPOSED_ALLELES[i],
                overlaps)
            if info_dict is None:
                if self.to_score_file:
                    self._write_for_scoring(record, i)
                continue
            annotation.extend(record.ALLELES[i+1] + "|" + x for x in
                              info_strings)
            over_threshold = []
            if self.min_delta or self.max_delta:
                for ds in annot_order[2:]:
                    if self.min_delta:
                        over_threshold.extend((x for x in info_dict[ds] if
                                               x >= self.min_delta))
                    if self.max_delta:
                        over_threshold.extend((x for x in info_dict[ds] if
                                               x <= self.max_delta))
                    if over_threshold:
                        keep_alleles[i] = True
                        break
                if not over_threshold:
                    keep_alleles[i] = False
                    continue
            if check_symbol and (self.min_delta or self.max_delta):
                for j in range(len(record.CSQ)):
                    gene_match = []
                    alt_j = record.CSQ[j]['alt_index'] -1
                    if alt_j == i:
                        for ds in annot_order[2:]:
                            if self.min_delta:
                                gene_match.extend((x for x in info_dict[ds] if
                                                   x >= self.min_delta and
                                                   info_dict['SYMBOL'] ==
                                                   record.CSQ[j]['SYMBOL']))
                            if self.max_delta:
                                gene_match.extend((x for x in info_dict[ds] if
                                                   x <= self.min_delta and
                                                   info_dict['SYMBOL'] ==
                                                   record.CSQ[j]['SYMBOL']))
                            if gene_match:
                                break
                    if gene_match:
                        keep_csq[j] = True
        if annotation:
            record.add_info_fields({'SpliceAI': ",".join(annotation)})
        return keep_alleles, keep_csq

    def _write_for_scoring(self, record, alt):
        if record.DECOMPOSED_ALLELES[alt].ALT != '*':
            self.to_score_file.write("{}\t{}\t.\t{}\t{}\t.\t.\t.\n".format(
                                           record.CHROM,
                                           record.DECOMPOSED_ALLELES[alt].POS,
                                           record.DECOMPOSED_ALLELES[alt].REF,
                                           record.DECOMPOSED_ALLELES[alt].ALT))
